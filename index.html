<!DOCTYPE html>
<html>
<head>
	<title>jsq - The JSON wrangler</title>
	
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<link rel="stylesheet" type="text/css" href="index.css">
	<link rel="stylesheet" type="text/css" href="prism.css">
</head>
<body>
	<div id="all">
		<h1><p>jsq</p>
</h1>
		
		<p>Take control of your JSON; slice, filter, map, transform,
calculate — it&#39;s up to you. All in a purpose-designed, simple language. With GZIP, it&#39;s less
than 5KB.</p>

		
		<div id="header">
<pre class="lang-javascript"><code>var o = {
  "data": [
    {"uid": 1, "grades": [5,7,8]},
    {"uid": 2, "grades": [3,9,6]}
  ],
  "users": {
    1: {"name": "Bruce Willis"},
    2: {"name": "Samuel L. Jackson"}
  }
};

jsq(o, '.users as $u | .data[] | {$u[.uid].name: (.grades|max)}');
// » [{"Bruce Willis":8}, {"Samuel L. Jackson":9}]</pre></code>
			
			
		</div>
		
		<!-- <iframe id="watchButton" src="http://ghbtns.com/github-btn.html?user=tjoekbezoer&repo=jsq&type=watch"
		  allowtransparency="true" frameborder="0" scrolling="0" width="50" height="20"></iframe> -->
		
		<section>
			<h2><p>What&#39;s next</p>
</h2>
			<ul>
<li>Download <a href="//raw.github.com/tjoekbezoer/jsq/master/jsq.js"><strong>jsq v0.1.0</strong></a> — not yet production ready!</li>
<li>Take jsq for a spin using my <a href="//tjoekbezoer.github.com/jsq/parser.html"><strong>internal test tool</strong></a></li>
<li>Run the <a href="//tjoekbezoer.github.com/jsq/test">test suite</a></li>
</ul>

			
			
			<hr/>
		</section>
		<section>
			<h2><p>Using jsq</p>
</h2>
			<p>Jsq allows you to mold your JSON data the way you want to. It does this
through it&#39;s own query language, called <em>jsq</em>. A jsq query is made up of
filters. A filter takes an input, and produces an output. Every filter is essentially
a little program performing a certain task. There&#39;s plenty of built-in functionality
that allows you to slice, filter, map, transform etc.</p>
<p>Filters can be combined in various ways to up their power — you can pipe the output of
one filter into another (like in UNIX), or collect the output of a filter
into an array for example.</p>
<p>Some filters produce multiple results, for instance there&#39;s one that
produces all the elements of its input array. Piping that filter
into a second runs the second filter for each element of the
array. Generally, things that would be done with loops and iteration
in other languages are just done by gluing filters together in jsq.</p>
<p>It&#39;s important to remember that every filter has an input and an
output. Even literals like &quot;hello&quot; or 42 are filters — they take an
input but always produce the same literal as output. Operations that
combine two filters, like addition, generally feed the same input to
both and combine the results. So, you can implement an averaging
filter as <code>add / length</code> — feeding the input array both to the <code>add</code>
filter and the <code>length</code> filter and dividing the results.</p>
<h2>Calling jsq</h2>
<p>The jsq function is defined as follows:</p>
<pre><code class="lang-javascript">var output = jsq( input..., query, iterator(value, key, output)?, context? )</code></pre>
<p>An arbitrary number of <code>input</code> objects can be passed (not required) after which a <code>query</code>
string is expected. Finally an optional <code>iterator</code> function and calling <code>context</code> can be
defined. Jsq always returns a results array, even when there&#39;s only a single or no results.</p>
<p>The iterator function is called for every result. It&#39;s passed 3 arguments; the value of the
result, the position of the result in the result array, and the complete result array. With
the last argument, the iterator is able to manipulate the result array that&#39;s returned by jsq.</p>
<h2>Good to know</h2>
<p>Jsq tries to mimic JavaScript&#39;s behavior as much as possible, especially with regards to
data types,  comparing values and logical operators. For example, <code>&quot;1&quot; == 1</code> will return
true while <code>&quot;1&quot; === 1</code> will return false,  <code>2 &amp;&amp; 0</code> will return 0, and <code>false || 2</code> will
return 2.</p>
<p>However, in some cases jsq&#39;s response will be different. <code>.foo = 2</code> will for instance not
return the same as JavaScript&#39;s <code>foo = 2</code>. The latter will evaluate to 2, while jsq
will return the entire object in which element &#39;<em>foo</em>&#39; now has value 2.</p>

			
			
			<hr/>
		</section>
		<section>
			<h2><p>Basic filters</p>
</h2>
			
			
			<div>
				<h3><p><code>.</code></p>
</h3>
				<p>The absolute simplest (and least interesting) filter
is <code>.</code>. This is a filter that takes its input and
produces it unchanged as output.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.</p>
</td></tr>
						<tr><td>Input</td><td><p>&quot;Hello, world!&quot;</p>
</td></tr>
						<tr><td>Output</td><td><p>&quot;Hello, world!&quot;</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>.foo</code></p>
</h3>
				<p>The simplest <em>useful</em> filter is .foo. When given a JSON object as input, it produces
the value at the key &quot;foo&quot;, or nothing if there&#39;s none present.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.foo</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;}</p>
</td></tr>
						<tr><td>Output</td><td><p>[42]</p>
</td></tr>
						<tr><td></td><td><p>.foo</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false}</p>
</td></tr>
						<tr><td>Output</td><td><p>[]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>.[&quot;foo&quot;]</code></p>
</h3>
				<p>You can also look up fields of an object using syntax like
<code>.[&quot;foo&quot;]</code> (.foo above is a shorthand version of this). This
one works for arrays as well, if the key is an
integer.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.[0]</p>
</td></tr>
						<tr><td>Input</td><td><p>[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]</p>
</td></tr>
						<tr><td>Output</td><td><p>{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true}</p>
</td></tr>
						<tr><td></td><td><p>.[2]</p>
</td></tr>
						<tr><td>Input</td><td><p>[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]</p>
</td></tr>
						<tr><td>Output</td><td><p>null</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>.[]</code></p>
</h3>
				<p>If you use the <code>.[&quot;foo&quot;]</code> syntax, but omit the index
entirely, it will return <em>all</em> of the elements of an
array. Running <code>.[]</code> with the input <code>[1,2,3]</code> will produce the
numbers as a list of three results, rather than as a single
array. This also works for objects.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.[]</p>
</td></tr>
						<tr><td>Input</td><td><p>[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]</p>
</td></tr>
						<tr><td>Output</td><td><p>[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]</p>
</td></tr>
						<tr><td></td><td><p>.[]</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true}</p>
</td></tr>
						<tr><td>Output</td><td><p>[&quot;JSON&quot;, true]</p>
</td></tr>
						<tr><td></td><td><p>.[]</p>
</td></tr>
						<tr><td>Input</td><td><p>[]</p>
</td></tr>
						<tr><td>Output</td><td><p>[]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>,</code></p>
</h3>
				<p>If two filters are separated by a comma, then the input will be fed into both and
there will be multiple outputs: first, all of the outputs produced by the left
expression, and then all of the outputs produced by the right. For instance, filter
<code>.foo, .bar</code>, produces both the &quot;foo&quot; fields and &quot;bar&quot; fields as separate outputs.</p>
<p>By combining expression like this, you are creating what is called a <em>list</em>. You can
read more about this in the next chapter <strong>Types and Values</strong>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.foo, .bar</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;foo&quot;: 42, &quot;bar&quot;: &quot;something else&quot;, &quot;baz&quot;: true}</p>
</td></tr>
						<tr><td>Output</td><td><p>[42, &quot;something else&quot;]</p>
</td></tr>
						<tr><td></td><td><p>.user, .projects[]</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;user&quot;:&quot;tjoekbezoer&quot;, &quot;projects&quot;: [&quot;jsq&quot;, &quot;wikiflow&quot;]}</p>
</td></tr>
						<tr><td>Output</td><td><p>[&quot;tjoekbezoer&quot;, &quot;jsq&quot;, &quot;wikiflow&quot;]</p>
</td></tr>
						<tr><td></td><td><p>.[4,2]</p>
</td></tr>
						<tr><td>Input</td><td><p>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</p>
</td></tr>
						<tr><td>Output</td><td><p>[&quot;e&quot;, &quot;c&quot;]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>|</code></p>
</h3>
				<p>The | operator combines two filters by feeding the result(s) of
the one on the left into the input of the one on the right. It&#39;s
pretty much the same as the Unix shell&#39;s pipe, if you&#39;re used to
that. </p>
<p>If the one on the left produces multiple results, the one on
the right will be run for each of those results. So, the
expression <code>.[] | .foo</code> retrieves the &quot;foo&quot; field of each
result of the input expression.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.[] | .name</p>
</td></tr>
						<tr><td>Input</td><td><p>[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]</p>
</td></tr>
						<tr><td>Output</td><td><p>[&quot;JSON&quot;, &quot;XML&quot;]</p>
</td></tr>
					</table>
				</div>
			</div>
			
			<hr/>
		</section>
		<section>
			<h2><p>Types and Values</p>
</h2>
			<p>jsq supports the same set of datatypes as JSON - strings, numbers, booleans, arrays,
objects, and &quot;null&quot;.</p>

			
			<div>
				<h3><p>Simple values</p>
</h3>
				<p>Strings, numbers, booleans and null are written the same way as in javascript. Just like
everything else in jsq, these simple values take an input and produce an output — <code>42</code> is
a valid jsq expression that takes an input, ignores it, and returns 42 instead.</p>
<p>Like in JSON, strings are delimited using &quot;double quotes&quot;. &#39;Single quotes&#39; are not allowed.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			<div>
				<h3><p>Arrays — <code>[]</code></p>
</h3>
				<p>Similar to JavaScript, <code>[]</code> is used to construct arrays, as in <code>[1,2,3]</code>. The elements
of the array can be any jsq expression. All of the results produced by all of the
expressions are collected into one big array. You can use it to construct an array out
of a known quantity of values (as in <code>[.foo, .bar, .baz]</code>) or to &quot;collect&quot; all the results
of a filter into an array (as in <code>[.items[].name]</code>)</p>
<p>If you have a filter <code>X</code> that produces four results, then the expression <code>[X]</code> will
produce a single result, an array of four elements.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>[.user, .projects[]]</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;user&quot;:&quot;tjoekbezoer&quot;, &quot;projects&quot;: [&quot;jsq&quot;, &quot;wikiflow&quot;]}</p>
</td></tr>
						<tr><td>Output</td><td><p>[[&quot;tjoekbezoer&quot;, &quot;jsq&quot;, &quot;wikiflow&quot;]]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p>Lists — <code>1,2,3</code></p>
</h3>
				<p>Once you understand the <code>,</code> operator, you can look at jsq&#39;s array
syntax in a different light: the expression <code>[1,2,3]</code> is not using a
built-in syntax for comma-separated arrays, but is actually applying
the <code>[]</code> operator (collect results) to the expression <code>1,2,3</code> which
produces a list of 3 integers.</p>
<p>A list will concatenate all results from all elements of the list.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			<div>
				<h3><p>Objects — <code>{}</code></p>
</h3>
				<p>Continuing JavaScript&#39;s familiarity, objects are constructed using <code>{}</code> — e.g.:
<code>{&quot;a&quot;: 42, &quot;b&quot;: 17}</code>.</p>
<p>If the keys are &quot;sensible&quot; (all alphanumeric characters), then
the quotes can be left off. The value can be any expression
(although you may need to wrap it in parentheses if it&#39;s a
complicated one — like when using a list), which gets applied to the {} expression&#39;s
input (remember, all filters have an input and an
output).</p>
<pre><code class="lang-jsq">{foo: .bar}</code></pre>
<p>will produce the JSON object <code>{&quot;foo&quot;: 42}</code> if given the JSON
object <code>{&quot;bar&quot;:42, &quot;baz&quot;:43}</code>. You can use this to select
particular fields of an object: if the input is an object
with &quot;user&quot;, &quot;title&quot;, &quot;id&quot;, and &quot;content&quot; fields and you
just want &quot;user&quot; and &quot;title&quot;, you can write</p>
<pre><code class="lang-jsq">{user: .user, title: .title}</code></pre>
<p>Because that&#39;s so common, there&#39;s a shortcut syntax: <code>{user, title}</code>.</p>
<p>If one of the expressions produces multiple results,
multiple dictionaries will be produced. If the input&#39;s</p>
<pre><code class="lang-javascript">{
  &quot;user&quot;:&quot;tjoekbezoer&quot;,
  &quot;titles&quot;:[&quot;JSQ Primer&quot;, &quot;More JSQ&quot;]
}</code></pre>
<p>then the expression</p>
<pre><code class="lang-jsq">{user, title: .titles[]}</code></pre>
<p>will produce two outputs: </p>
<pre><code class="lang-javascript">[
  {&quot;user&quot;:&quot;tjoekbezoer&quot;, &quot;title&quot;: &quot;JSQ Primer&quot;},
  {&quot;user&quot;:&quot;tjoekbezoer&quot;, &quot;title&quot;: &quot;More JSQ&quot;}
]</code></pre>
<p>Putting parentheses around the key means it will be evaluated as an
expression. With the same input as above,</p>
<pre><code class="lang-jsq">{(.user): .titles}</code></pre>
<p>produces</p>
<pre><code class="lang-javascript">{&quot;tjoekbezoer&quot;: [&quot;JSQ Primer&quot;, &quot;More JSQ&quot;]}</code></pre>
<p>Simple expressions, like a single filter, can also be used without the parentheses. A
filter used as a key name can return only one result, or jsq will throw an error.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>{user, title: .titles[]}</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;user&quot;:&quot;tjoekbezoer&quot;,&quot;titles&quot;:[&quot;JSQ Primer&quot;, &quot;More JSQ&quot;]}</p>
</td></tr>
						<tr><td>Output</td><td><p>[{&quot;user&quot;:&quot;tjoekbezoer&quot;, &quot;title&quot;: &quot;JSQ Primer&quot;}, {&quot;user&quot;:&quot;tjoekbezoer&quot;, &quot;title&quot;: &quot;More JSQ&quot;}]</p>
</td></tr>
						<tr><td></td><td><p>{(.user): .titles}</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;user&quot;:&quot;tjoekbezoer&quot;,&quot;titles&quot;:[&quot;JSQ Primer&quot;, &quot;More JSQ&quot;]}</p>
</td></tr>
						<tr><td>Output</td><td><p>[{&quot;tjoekbezoer&quot;: [&quot;JSQ Primer&quot;, &quot;More JSQ&quot;]}]</p>
</td></tr>
					</table>
				</div>
			</div>
			
			<hr/>
		</section>
		<section>
			<h2><p>Builtin operators</p>
</h2>
			<p>Some jsq operators (for instance, <code>+</code>) do different things depending on the type of their
arguments (arrays, numbers, etc.). Jsq will mimic JavaScript as much as possible, so <code>&quot;1&quot;+1</code>
will produce <code>&quot;11&quot;</code>, and <code>&quot;1&quot;-1</code> will produce <code>0</code>.</p>
<p>If one or both expressions produce multiple results, the operation will be performed for
every possible combination of results. So</p>
<pre><code>(1,2) + 3</code></pre>
<p>Will produce <code>[4,5]</code>, and</p>
<pre><code>(1,2) * (3,4)</code></pre>
<p>Will produce <code>[3,4,6,8]</code>.</p>

			
			<div>
				<h3><p>Addition - <code>+</code></p>
</h3>
				<p>The operator <code>+</code> takes two filters, applies them both
to the same input, and adds the results together. What
&quot;adding&quot; means depends on the types involved:</p>
<ul>
<li><p><strong>Numbers</strong> are added by normal arithmetic.</p>
</li>
<li><p><strong>Arrays</strong> are added by being concatenated into a larger array.</p>
</li>
<li><p><strong>Strings</strong> are added by being joined into a larger string.</p>
</li>
<li><p><strong>Objects</strong> are added by merging, that is, inserting all
  the key-value pairs from both objects into a single
  combined object. If both objects contain a value for the
  same key, the object on the right of the <code>+</code> will be used.</p>
</li>
</ul>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.a + 1</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;a&quot;: 7}</p>
</td></tr>
						<tr><td>Output</td><td><p>[8]</p>
</td></tr>
						<tr><td></td><td><p>.a + .b</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;a&quot;: [1,2], &quot;b&quot;: [3,4]}</p>
</td></tr>
						<tr><td>Output</td><td><p>[[1,2,3,4]]</p>
</td></tr>
						<tr><td></td><td><p>.a + null</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;a&quot;: 1}</p>
</td></tr>
						<tr><td>Output</td><td><p>[1]</p>
</td></tr>
						<tr><td></td><td><p>.a + 1</p>
</td></tr>
						<tr><td>Input</td><td><p>{}</p>
</td></tr>
						<tr><td>Output</td><td><p>[1]</p>
</td></tr>
						<tr><td></td><td><p>{a: 1} + {b: 2} + {c: 3} + {a: 42}</p>
</td></tr>
						<tr><td>Input</td><td><p>null</p>
</td></tr>
						<tr><td>Output</td><td><p>[{&quot;a&quot;: 42, &quot;b&quot;: 2, &quot;c&quot;: 3}]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p>Subtraction - <code>-</code></p>
</h3>
				<ul>
<li><strong>Numbers</strong> are subtracted by normal arithmetic.</li>
<li><strong>Arrays</strong> are being subtracted by removing all occurences of the second array&#39;s
elements from the first array.</li>
<li><strong>Objects</strong> are subtracted similarly — all keys from the second object will be removed
from the first object.</li>
</ul>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>4 - .a</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;a&quot;:3}</p>
</td></tr>
						<tr><td>Output</td><td><p>[1]</p>
</td></tr>
						<tr><td></td><td><p>. - [&quot;xml&quot;, &quot;yaml&quot;]</p>
</td></tr>
						<tr><td>Input</td><td><p>[&quot;xml&quot;, &quot;yaml&quot;, &quot;json&quot;]</p>
</td></tr>
						<tr><td>Output</td><td><p>[[&quot;json&quot;]]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p>Multiplication, division - <code>*</code> and <code>/</code></p>
</h3>
				<p>These operators only work on numbers, and do the expected.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>10 / . * 3</p>
</td></tr>
						<tr><td>Input</td><td>5</td></tr>
						<tr><td>Output</td><td><p>[6]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p>Binary — <code>and</code>, <code>or</code> and <code>xor</code></p>
</h3>
				<p>These operators are similar to JavaScript&#39;s <code>&amp;</code>, <code>|</code> and <code>^</code>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			
			<hr/>
		</section>
		<section>
			<h2><p>Assignment</p>
</h2>
			<p>Assignment works a little differently in jsq than in most
programming languages. jsq doesn&#39;t distinguish between references
to and copies of something - two objects or arrays are either
equal or not equal, without any further notion of being &quot;the
same object&quot; or &quot;not the same object&quot;.</p>
<p>If an object has two fields which are arrays, <code>.foo</code> and <code>.bar</code>,
and you append something to <code>.foo</code>, then <code>.bar</code> will not get
bigger. Even if you&#39;ve just set <code>.bar = .foo</code>.</p>

			
			<div>
				<h3><p><code>=</code></p>
</h3>
				<p>The assignment operation <code>.foo = 1</code> will take as input an object
and produce as output an object with the &quot;foo&quot; field set to
1. There is no notion of &quot;modifying&quot; or &quot;changing&quot; something
in jsq - all jsq values are immutable. For instance,</p>
<pre><code class="lang-jsq">.foo = .bar | .foo.baz = 1</code></pre>
<p>will not have the side-effect of setting .bar.baz to be set
to 1, as the similar-looking program in Javascript, Python,
Ruby or other languages would. Unlike these languages, there is
no notion of two arrays or objects being &quot;the same array&quot; or
&quot;the same object&quot;. They can be equal, or not equal, but if
we change one of them in no circumstances will the other
change behind our backs.</p>
<p>This means that it&#39;s impossible to build circular values in
jsq (such as an array whose first element is itself). This is
quite intentional, and ensures that anything a jsq program
can produce can be represented in JSON.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>|=</code></p>
</h3>
				<p>As well as the assignment operator &#39;=&#39;, jsq provides the &quot;update&quot;
operator &#39;|=&#39;, which takes a filter on the right-hand side and
works out the new value for the property being assigned to by running
the old value through this expression. For instance, <code>.foo |= .+1</code> will
build an object with the &quot;foo&quot; field set to the input&#39;s &quot;foo&quot; plus 1.</p>
<p>This example should show the difference between &#39;=&#39; and &#39;|=&#39;. Provide input</p>
<pre><code class="lang-javascript">{&quot;a&quot;: {&quot;b&quot;: 10}, &quot;b&quot;: 20}</code></pre>
<p>to <code>.a = .b</code> and it produces <code>{&quot;a&quot;: 20, &quot;b&quot;: 20}</code>.<br>to <code>.a |= .b</code> and it produces <code>{&quot;a&quot;: 10, &quot;b&quot;: 20}</code>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></p>
</h3>
				<p>jsq has a few operators of the form <code>a op= b</code>, which are all equivalent to
<code>a |= . op b</code>. So for example, <code>+= 1</code> can be used to increment values.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.foo += 1</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;foo&quot;: 42}</p>
</td></tr>
						<tr><td>Output</td><td><p>{&quot;foo&quot;: 43}</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p>Complex assignments</p>
</h3>
				<p>Lots more things are allowed on the left-hand side of a jsq assignment
than in most langauges. We&#39;ve already seen simple field accesses on
the left hand side, and it&#39;s no surprise that array accesses work just
as well:</p>
<pre><code class="lang-jsq">.posts[0].title = &quot;JSQ Manual&quot;</code></pre>
<p>What may come as a surprise is that the expression on the left may
produce multiple results, referring to different points in the input
document:</p>
<pre><code class="lang-jsq">.posts[].comments |= . + [&quot;this is great&quot;]</code></pre>
<p>That example appends the string &quot;this is great&quot; to the &quot;comments&quot;
array of each post in the input (where the input is an object with a
field &quot;posts&quot; which is an array of posts).</p>
<p>When jsq encounters an assignment like &#39;a = b&#39;, it records the &quot;path&quot;
taken to select a part of the input document while executing a. This
path is then used to find which part of the input to change while
executing the assignment. Any filter may be used on the
left-hand side of an equals - whichever paths it selects from the
input will be where the assignment is performed.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			
			<hr/>
		</section>
		<section>
			<h2><p>Comparisons and Conditionals</p>
</h2>
			
			
			<div>
				<h3><p><code>==</code>, <code>!=</code>, <code>===</code></p>
</h3>
				<p>For <a href="http://en.wikipedia.org/wiki/Scalar_(computing)">scalars</a>, these comparison operators behave the same as their Javascript equivalents.
For arrays and objects, a deep comparison is performed.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.[] == 1</p>
</td></tr>
						<tr><td>Input</td><td><p>[1, 1.0, &quot;1&quot;, &quot;banana&quot;]</p>
</td></tr>
						<tr><td>Output</td><td><p>true</p>
,<p>true</p>
,<p>false</p>
,<p>false</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code></p>
</h3>
				<p>The comparison operators <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code> behave as expected. They can also be
used to compare arrays and objects.</p>
<p>The ordering is the same as that described for the built-in function <code>sort</code>, below.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>. &lt; 5</p>
</td></tr>
						<tr><td>Input</td><td>2</td></tr>
						<tr><td>Output</td><td><p>true</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>if(cond, then[, else])</code></p>
</h3>
				<p>Consider the expression <code>if(A, B, C)</code>. If <code>A</code> evaluates as truthy, <code>B</code> will be executed.
Otherwise it will execute <code>C</code>, if provided.</p>
<p>If the condition <code>A</code> is an expression producing multiple results, it is considered &quot;true&quot;
if any of those results is truthy. If it produces zero results, it&#39;s considered false.</p>
<p>More about truthy values: <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript">Truth, equality and JavaScript</a></p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>if . == 0 then
  &quot;zero&quot;
elif . == 1 then
  &quot;one&quot;
else
  &quot;many&quot;
end</p>
</td></tr>
						<tr><td>Input</td><td>2</td></tr>
						<tr><td>Output</td><td><p>&quot;many&quot;</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>&amp;&amp;</code>, <code>||</code>, <code>!</code></p>
</h3>
				<p>jsq supports the normal Boolean operators <code>&amp;&amp;</code> and <code>||</code>. They have the
same standard of truth as <code>if</code> expressions.</p>
<p>If an operand of one of these operators produces multiple
results, the operator itself will produce a result for each input.</p>
<p>The boolean operators behave the same as JavaScript&#39;s, returning the value of the last
correct operand. So for example <code>0 &amp;&amp; 2</code> returns <code>2</code>; <code>!1 || 3</code> returns <code>3</code>.</p>
<p><code>!</code> simply negates the proceding value.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>42 and &quot;a string&quot;</p>
</td></tr>
						<tr><td>Input</td><td><p>null</p>
</td></tr>
						<tr><td>Output</td><td><p>true</p>
</td></tr>
						<tr><td></td><td><p>(true, false) or false</p>
</td></tr>
						<tr><td>Input</td><td><p>null</p>
</td></tr>
						<tr><td>Output</td><td><p>true</p>
,<p>false</p>
</td></tr>
						<tr><td></td><td><p>(true, false) and (true, false)</p>
</td></tr>
						<tr><td>Input</td><td><p>null</p>
</td></tr>
						<tr><td>Output</td><td><p>true</p>
,<p>false</p>
,<p>false</p>
,<p>false</p>
</td></tr>
						<tr><td></td><td><p>[true, false | not]</p>
</td></tr>
						<tr><td>Input</td><td><p>null</p>
</td></tr>
						<tr><td>Output</td><td><p>[false, true]</p>
</td></tr>
					</table>
				</div>
			</div>
			
			<hr/>
		</section>
		<section>
			<h2><p>Variables</p>
</h2>
			<p>In jsq, all filters have an input and an output, so manual
plumbing is not necessary to pass a value from one part of a program
to the next. Many expressions, for instance <code>a + b</code>, pass their input
to two distinct subexpressions (here <code>a</code> and <code>b</code> are both passed the
same input), so variables aren&#39;t usually necessary in order to use a
value twice.</p>
<p>For instance, calculating the average value of an array of numbers
requires a few variables in most languages; at least one to hold the
array, and perhaps one for each element or for a loop counter. In jsq, it&#39;s
simply <code>add / length</code> — the <code>add</code> expression is given the array and
produces its sum, and the <code>length</code> expression is given the array and
produces its length.</p>
<p>So, there&#39;s generally a cleaner way to solve most problems in jsq that
defining variables. Still, sometimes they do make things easier, so jsq
lets you define variables using <code>expression as $variable</code>. All
variable names start with <code>$</code>. Here&#39;s a slightly uglier version of the
array-averaging example:</p>
<pre><code class="lang-jsq">length as $array_length | add / $array_length</code></pre>
<p>We&#39;ll need a more complicated problem to find a situation where using
variables actually makes our lives easier.</p>
<p>Suppose we have an array of blog posts, with &quot;author&quot; and &quot;title&quot;
fields, and another object which is used to map author usernames to
real names. Our input looks like:</p>
<pre><code class="lang-javascript">{
  &quot;posts&quot;: [
    {&quot;title&quot;: &quot;Frist psot&quot;, &quot;author&quot;: &quot;anon&quot;},
    {&quot;title&quot;: &quot;A well-written article&quot;, &quot;author&quot;: &quot;person1&quot;}],
  &quot;realnames&quot;: {
    &quot;anon&quot;: &quot;Anonymous Coward&quot;,
    &quot;person1&quot;: &quot;Person McPherson&quot;
  }
}</code></pre>
<p>We want to produce the posts with the author field containing a real
name, as in:</p>
<pre><code class="lang-javascript">[
  {&quot;title&quot;: &quot;Frist psot&quot;, &quot;author&quot;: &quot;Anonymous Coward&quot;},
  {&quot;title&quot;: &quot;A well-written article&quot;, &quot;author&quot;: &quot;Person McPherson&quot;}
]</code></pre>
<p>We use a variable, $names, to store the realnames object, so that we
can refer to it later when looking up author usernames:</p>
<pre><code class="lang-jsq">.realnames as $names | .posts[] | {title, author: $names[.author]}</code></pre>
<p>The expression &quot;foo as $x&quot; runs foo, puts the result in $x,
and returns the original input. Apart from the side-effect
of binding the variable, it has the same effect as &quot;.&quot;.</p>

			
			
			<hr/>
		</section>
		<section>
			<h2><p>Built-in functions</p>
</h2>
			<p>Jsq comes with a set of built-in functions that allow you to perform extra operations on your
data, like filtering or transforming. Every function listed here is written in JavaScript,
and defined in the public <code>jsq.fn</code> object, so it&#39;s possible to alter them, or add new ones
of your own.</p>

			
			<div>
				<h3><p><code>length</code></p>
</h3>
				<p>The built-in function <code>length</code> gets the length of various
different types of values:</p>
<ul>
<li>The length of a <strong>string</strong> is the number of characters.</li>
<li>The length of an <strong>array</strong> is the number of elements.</li>
<li>The length of an <strong>object</strong> is the number of key-value pairs.</li>
<li>The length of <strong>null</strong> is zero.</li>
</ul>
<p>When trying to get the length of a number, it will return nothing.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.[] | length</p>
</td></tr>
						<tr><td>Input</td><td><p>[[1,2], &quot;string&quot;, {&quot;a&quot;:2}, null]</p>
</td></tr>
						<tr><td>Output</td><td>2,6,1,0</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>keys</code></p>
</h3>
				<p>The built-in function <code>keys</code>, when given an object, returns its keys
in a list. When given an array, it returns the valid indices  for that
array: the integers from 0 to length-1.</p>
<p>When &#39;keying&#39; an object, do not rely on the sort order. The order in which the
keys are returned is defined by the browser implementation of object iteration,
which is not cross-browser consistent.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>keys</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;abc&quot;: 1, &quot;abcd&quot;: 2, &quot;Foo&quot;: 3}</p>
</td></tr>
						<tr><td>Output</td><td><p>[&quot;Foo&quot;, &quot;abc&quot;, &quot;abcd&quot;]</p>
</td></tr>
						<tr><td></td><td><p>keys</p>
</td></tr>
						<tr><td>Input</td><td><p>[42,3,35]</p>
</td></tr>
						<tr><td>Output</td><td><p>[0,1,2]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>pairs</code></p>
</h3>
				<p>When passed an object, <code>pairs</code> will return a list of arrays, where every array
is a key-value combination. This also works on arrays.</p>
<p>Like with the <code>keys</code> function, do not rely on sort order when &#39;pairing&#39; an object.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>select</code></p>
</h3>
				<p>The function <code>select(foo)</code> produces its input unchanged if
<code>foo</code> returns true for that input, and produces no output
otherwise.</p>
<p>It&#39;s useful for filtering lists, objects and arrays: <code>[1,2,3] | map(select(. &gt;= 2))</code>
will give you <code>[2,3]</code>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>map(select(. &gt;= 2))</p>
</td></tr>
						<tr><td>Input</td><td><p>[1,5,3,0,7]</p>
</td></tr>
						<tr><td>Output</td><td><p>[5,3,7]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>empty</code></p>
</h3>
				<p><code>empty</code> returns no results. None at all. Not even <code>null</code>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>1, empty, 2</p>
</td></tr>
						<tr><td>Input</td><td><p>null</p>
</td></tr>
						<tr><td>Output</td><td>1,2</td></tr>
						<tr><td></td><td><p>[1,2,empty,3]</p>
</td></tr>
						<tr><td>Input</td><td><p>null</p>
</td></tr>
						<tr><td>Output</td><td><p>[1,2,3]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>map(x)</code></p>
</h3>
				<p>For any filter <code>x</code>, <code>map(x)</code> will run that filter for each element of the input
object/array, and produce a list of results equal to the amount of elements.
<code>map(.+1)</code> will increment each element of an array of numbers.</p>
<p><code>map(x)</code> is equivalent to <code>.[] | x</code>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>map(.+1)</p>
</td></tr>
						<tr><td>Input</td><td><p>[1,2,3]</p>
</td></tr>
						<tr><td>Output</td><td><p>[2,3,4]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>add</code></p>
</h3>
				<p>The filter <code>add</code> takes as input an array, and produces as
output the elements of the array added together. This might
mean summed, concatenated or merged depending on the types
of the elements of the input array - the rules are the same
as those for the <code>+</code> operator (described above).</p>
<p>If the input is an empty array, <code>add</code> returns <code>null</code>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>add</p>
</td></tr>
						<tr><td>Input</td><td><p>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</p>
</td></tr>
						<tr><td>Output</td><td><p>&quot;abc&quot;</p>
</td></tr>
						<tr><td></td><td><p>add</p>
</td></tr>
						<tr><td>Input</td><td><p>[1, 2, 3]</p>
</td></tr>
						<tr><td>Output</td><td>6</td></tr>
						<tr><td></td><td><p>add</p>
</td></tr>
						<tr><td>Input</td><td><p>[]</p>
</td></tr>
						<tr><td>Output</td><td><p>null</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>tonumber</code></p>
</h3>
				<p>The <code>tonumber</code> function will parse its input as a number. It&#39;s not able to parse objects
and arrays, nor can it parse strings not starting with a number. In these cases, <code>tonumber</code>
will return <code>null</code>. Parsing  booleans results in <code>1</code> or <code>0</code>.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.[] | tonumber</p>
</td></tr>
						<tr><td>Input</td><td><p>[1, &quot;1&quot;]</p>
</td></tr>
						<tr><td>Output</td><td>1,1</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>tostring</code></p>
</h3>
				<p>The <code>tostring</code> function prints its input as a string. Jsq uses <code>JSON.stringify</code> for this,
so make sure it is available (in older browser you might need to include <a href="https://github.com/douglascrockford/JSON-js">json2.js</a>)</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>.[] | tostring</p>
</td></tr>
						<tr><td>Input</td><td><p>[1, &quot;1&quot;, [1]]</p>
</td></tr>
						<tr><td>Output</td><td><p>&quot;1&quot;</p>
,<p>&quot;1&quot;</p>
,<p>&quot;[1]&quot;</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>sort</code></p>
</h3>
				<p>The <code>sort</code> function sorts its input, which must be an
array. Values are sorted in the following order:</p>
<ul>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>true</code></li>
<li>numbers</li>
<li>strings, in alphabetical order (by unicode codepoint value)</li>
<li>arrays, in lexical order</li>
<li>objects</li>
</ul>
<p>The ordering for objects is a little complex: first they&#39;re
compared by comparing their sets of keys (as arrays in
sorted order), and if their keys are equal then the values
are compared key by key.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>sort</p>
</td></tr>
						<tr><td>Input</td><td><p>[8,3,null,6]</p>
</td></tr>
						<tr><td>Output</td><td><p>[null,3,6,8]</p>
</td></tr>
						<tr><td></td><td><p>sort_by(.foo)</p>
</td></tr>
						<tr><td>Input</td><td><p>[{&quot;foo&quot;:4, &quot;bar&quot;:10}, {&quot;foo&quot;:3, &quot;bar&quot;:100}, {&quot;foo&quot;:2, &quot;bar&quot;:1}]</p>
</td></tr>
						<tr><td>Output</td><td><p>[{&quot;foo&quot;:2, &quot;bar&quot;:1}, {&quot;foo&quot;:3, &quot;bar&quot;:100}, {&quot;foo&quot;:4, &quot;bar&quot;:10}]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>min</code>, <code>max</code></p>
</h3>
				<p>Find the minimum or maximum element of the input array. Providing a filter as argument
allows you to specify a particular field or property to examine, e.g. <code>min(.foo)</code>
finds the object with the smallest <code>foo</code> field.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>min</p>
</td></tr>
						<tr><td>Input</td><td><p>[5,4,2,7]</p>
</td></tr>
						<tr><td>Output</td><td><p>2</p>
</td></tr>
						<tr><td></td><td><p>max_by(.foo)</p>
</td></tr>
						<tr><td>Input</td><td><p>[{&quot;foo&quot;:1, &quot;bar&quot;:14}, {&quot;foo&quot;:2, &quot;bar&quot;:3}]</p>
</td></tr>
						<tr><td>Output</td><td><p>{&quot;foo&quot;:2, &quot;bar&quot;:3}</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>not</code></p>
</h3>
				<p>This function simply negates the input it receives.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>not</p>
</td></tr>
						<tr><td>Input</td><td><p>[0,1,2]</p>
</td></tr>
						<tr><td>Output</td><td><p>[true,false,false]</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>recurse</code></p>
</h3>
				<p>The <code>recurse</code> function allows you to search through a
recursive structure, and extract interesting data from all
levels. Suppose your input represents a filesystem:</p>
<pre><code class="lang-javascript">{&quot;name&quot;: &quot;/&quot;, &quot;children&quot;: [
  {&quot;name&quot;: &quot;/bin&quot;, &quot;children&quot;: [
    {&quot;name&quot;: &quot;/bin/ls&quot;, &quot;children&quot;: []},
    {&quot;name&quot;: &quot;/bin/sh&quot;, &quot;children&quot;: []}
  ]},
  {&quot;name&quot;: &quot;/home&quot;, &quot;children&quot;: [
    {&quot;name&quot;: &quot;/home/daan&quot;, &quot;children&quot;: [
      {&quot;name&quot;: &quot;/home/daan/jsq&quot;, &quot;children&quot;: []}
    ]}
  ]}
]}</code></pre>
<p>Now suppose you want to extract all of the filenames
present. You need to retrieve <code>.name</code>, <code>.children[].name</code>,
<code>.children[].children[].name</code>, and so on. You can do this
with:</p>
<pre><code class="lang-jsq">recurse(.children[]) | .name</code></pre>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
						<tr><td></td><td><p>recurse(.foo[])</p>
</td></tr>
						<tr><td>Input</td><td><p>{&quot;foo&quot;:[{&quot;foo&quot;: []}, {&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]}</p>
</td></tr>
						<tr><td>Output</td><td><p>{&quot;foo&quot;:[{&quot;foo&quot;:[]},{&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]}</p>
,<p>{&quot;foo&quot;:[]}</p>
,<p>{&quot;foo&quot;:[{&quot;foo&quot;:[]}]}</p>
,<p>{&quot;foo&quot;:[]}</p>
</td></tr>
					</table>
				</div>
			</div>
			<div>
				<h3><p><code>format(string)</code></p>
</h3>
				<p>Much like a simplified sprintf, <code>format</code> accepts an array of values to be integrated
into a custom string.</p>

			</div>
			<div class="examples">
				<div class="header">Examples</div>
				<div class="table">
					<table>
					</table>
				</div>
			</div>
			
			<hr/>
		</section>
		<section>
			<h2><p>Acknowledgements &amp; thanks</p>
</h2>
			<ul>
<li>Syntax and documentation inspired by the excellent <a href="//stedolan.github.com/jq">jq project</a></li>
<li>Above-the-fold design inspired by <a href="http://lodash.com">Lo-Dash</a></li>
<li>Syntax highlighting with <a href="http://prismjs.com">Prism</a></li>
</ul>

			
			
			<hr/>
		</section>
		
		<div id="legal">
			jsq is licensed under the <a href="//raw.github.com/tjoekbezoer/jsq/master/LICENSE-MIT">MIT license</a> (code)
			and the <a href="http://creativecommons.org/licenses/by/3.0/">CC-BY-3.0 license</a> (docs).
		</div>
	</div>
	
	<script type="text/javascript" src="prism.min.js"></script>
	<script type="text/javascript" src="examples.js"></script>
</body>
</html>